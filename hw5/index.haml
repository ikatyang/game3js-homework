!!! 5
%html
	%head
		%meta(charset='utf-8')
		%title='Game3js Homework5'
		%script(src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js')
		%script(src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js')
		%script(src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r81/three.min.js')
		%script(src='../src/OrbitControls.js')
		:css
			body {
				margin: 0;
				overflow: hidden;
			}
			.top {
				position: absolute;
				width: 100%;
				padding: 10px;
				text-align: center;
				top: 1em;
				color: yellow;
			}
		%script#explosion_vertex_shader(type='x-shader/x-vertex')
			:plain
				//
				// GLSL textureless classic 3D noise "cnoise",
				// with an RSL-style periodic variant "pnoise".
				// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
				// Version: 2011-10-11
				//
				// Many thanks to Ian McEwan of Ashima Arts for the
				// ideas for permutation and gradient selection.
				//
				// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
				// Distributed under the MIT license. See LICENSE file.
				// https://github.com/ashima/webgl-noise
				//

				vec3 mod289(vec3 x)
				{
				  return x - floor(x * (1.0 / 289.0)) * 289.0;
				}

				vec4 mod289(vec4 x)
				{
				  return x - floor(x * (1.0 / 289.0)) * 289.0;
				}

				vec4 permute(vec4 x)
				{
				  return mod289(((x*34.0)+1.0)*x);
				}

				vec4 taylorInvSqrt(vec4 r)
				{
				  return 1.79284291400159 - 0.85373472095314 * r;
				}

				vec3 fade(vec3 t) {
				  return t*t*t*(t*(t*6.0-15.0)+10.0);
				}

				// Classic Perlin noise
				float cnoise(vec3 P)
				{
				  vec3 Pi0 = floor(P); // Integer part for indexing
				  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
				  Pi0 = mod289(Pi0);
				  Pi1 = mod289(Pi1);
				  vec3 Pf0 = fract(P); // Fractional part for interpolation
				  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
				  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
				  vec4 iy = vec4(Pi0.yy, Pi1.yy);
				  vec4 iz0 = Pi0.zzzz;
				  vec4 iz1 = Pi1.zzzz;

				  vec4 ixy = permute(permute(ix) + iy);
				  vec4 ixy0 = permute(ixy + iz0);
				  vec4 ixy1 = permute(ixy + iz1);

				  vec4 gx0 = ixy0 * (1.0 / 7.0);
				  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
				  gx0 = fract(gx0);
				  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
				  vec4 sz0 = step(gz0, vec4(0.0));
				  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
				  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

				  vec4 gx1 = ixy1 * (1.0 / 7.0);
				  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
				  gx1 = fract(gx1);
				  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
				  vec4 sz1 = step(gz1, vec4(0.0));
				  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
				  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

				  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
				  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
				  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
				  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
				  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
				  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
				  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
				  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

				  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
				  g000 *= norm0.x;
				  g010 *= norm0.y;
				  g100 *= norm0.z;
				  g110 *= norm0.w;
				  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
				  g001 *= norm1.x;
				  g011 *= norm1.y;
				  g101 *= norm1.z;
				  g111 *= norm1.w;

				  float n000 = dot(g000, Pf0);
				  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
				  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
				  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
				  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
				  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
				  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
				  float n111 = dot(g111, Pf1);

				  vec3 fade_xyz = fade(Pf0);
				  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
				  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
				  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
				  return 2.2 * n_xyz;
				}

				// Classic Perlin noise, periodic variant
				float pnoise(vec3 P, vec3 rep)
				{
				  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
				  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
				  Pi0 = mod289(Pi0);
				  Pi1 = mod289(Pi1);
				  vec3 Pf0 = fract(P); // Fractional part for interpolation
				  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
				  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
				  vec4 iy = vec4(Pi0.yy, Pi1.yy);
				  vec4 iz0 = Pi0.zzzz;
				  vec4 iz1 = Pi1.zzzz;

				  vec4 ixy = permute(permute(ix) + iy);
				  vec4 ixy0 = permute(ixy + iz0);
				  vec4 ixy1 = permute(ixy + iz1);

				  vec4 gx0 = ixy0 * (1.0 / 7.0);
				  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
				  gx0 = fract(gx0);
				  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
				  vec4 sz0 = step(gz0, vec4(0.0));
				  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
				  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

				  vec4 gx1 = ixy1 * (1.0 / 7.0);
				  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
				  gx1 = fract(gx1);
				  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
				  vec4 sz1 = step(gz1, vec4(0.0));
				  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
				  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

				  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
				  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
				  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
				  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
				  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
				  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
				  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
				  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

				  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
				  g000 *= norm0.x;
				  g010 *= norm0.y;
				  g100 *= norm0.z;
				  g110 *= norm0.w;
				  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
				  g001 *= norm1.x;
				  g011 *= norm1.y;
				  g101 *= norm1.z;
				  g111 *= norm1.w;

				  float n000 = dot(g000, Pf0);
				  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
				  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
				  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
				  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
				  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
				  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
				  float n111 = dot(g111, Pf1);

				  vec3 fade_xyz = fade(Pf0);
				  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
				  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
				  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
				  return 2.2 * n_xyz;
				}

				// Include the Ashima code here!
				 
				varying vec2 vUv;
				varying float noise;
				uniform float time;

				float turbulence( vec3 p ) {
				  float w = 100.0;
				  float t = -.5;
				  for (float f = 1.0 ; f <= 10.0 ; f++ ){
					float power = pow( 2.0, f );
					t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
				  }
				  return t;
				}

				void main() {

				  vUv = uv;

				  noise = 10.0 *  -.10 * turbulence( .5 * normal + time );
				  float b = 5.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );
				  float displacement = - 10. * noise + b;
				  
				  vec3 newPosition = position + normal * displacement;
				  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );

				}

		%script#explosion_fragment_shader(type='x-shader/x-vertex')
			:plain
				varying vec2 vUv;
				varying float noise;
				uniform sampler2D tExplosion;

				float random( vec3 scale, float seed ){
				  return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed ) ;
				}

				void main() {

				  float r = .01 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );
				  vec2 tPos = vec2( 0, 1.3 * noise + r );
				  vec4 color = texture2D( tExplosion, tPos );
				  gl_FragColor = vec4( color.rgb, 1.0 );
				}
	%body
		.top='GP_HW5'
		:javascript
			function OBB(mesh) {
				
				if (!mesh.geometry.boundingBox)
					mesh.geometry.computeBoundingBox();
				
				this.center = mesh.position.clone().add(mesh.geometry.boundingBox.getCenter());
				this.size = mesh.geometry.boundingBox.getSize();
				
				var xAxis = new THREE.Vector3();
				var yAxis = new THREE.Vector3();
				var zAxis = new THREE.Vector3();
				mesh.matrix.extractBasis(xAxis, yAxis, zAxis);
				this.axes = [xAxis, yAxis, zAxis];
			}
			Object.assign(OBB.prototype, {
				
				intersectsOBB: (function () {
					
					function getProjectLength(vector, axis) {
						var project = vector.clone().projectOnVector(axis);
						var projectLengths = project.divide(axis).toArray();
						for (var i = 0; i < projectLengths.length; i++)
							if (isFinite(projectLengths[i]))
								return projectLengths[i];
						return 0;
					}
					
					function getOBBVertices(obb) {
						var vertices = [];
						for (var i = -0.5; i <= 0.5; i++)
							for (var j = -0.5; j <= 0.5; j++)
								for (var k = -0.5; k <= 0.5; k++)
									vertices.push(obb.center.clone()
										.addScaledVector(obb.axes[0], obb.size.x * i)
										.addScaledVector(obb.axes[1], obb.size.y * j)
										.addScaledVector(obb.axes[2], obb.size.z * k));
						return vertices;
					}
					
					function satTest(obb1, obb2, axis) {
						
						var center1 = getProjectLength(obb1.center, axis);
						var center2 = getProjectLength(obb2.center, axis);
						
						var isLeftL = (center1 < center2);
						
						var centerL = isLeftL ? center1 : center2;
						var centerR = isLeftL ? center2 : center1;
						
						var verticesL = isLeftL ? getOBBVertices(obb1) : getOBBVertices(obb2);
						var verticesR = isLeftL ? getOBBVertices(obb2) : getOBBVertices(obb1);
						
						var vertexLR = -Number.MAX_VALUE;
						for (var i = 0; i < verticesL.length; i++)
							vertexLR = Math.max(vertexLR, getProjectLength(verticesL[i], axis));
							
						var vertexRL = Number.MAX_VALUE;
						for (var i = 0; i < verticesR.length; i++)
							vertexRL = Math.min(vertexRL, getProjectLength(verticesR[i], axis));
							
						var lengthL = vertexLR - centerL;
						var lengthR = centerR - vertexRL;
						var lengthC = centerR - centerL;
						
						return (lengthL + lengthR >= lengthC);
					}
					
					return function (obb) {
						
						var axes = [].concat(this.axes, obb.axes);
						
						for (var i = 0; i < this.axes.length; i++)
							for (var j = 0; j < obb.axes.length; j++)
								axes.push(this.axes[i].clone().cross(obb.axes[j]).normalize());
						
						for (var i = 0; i < axes.length; i++)
							if (!satTest(this, obb, axes[i]))
								return false;
						
						return true;
					};
					
				})(),
				
			});
		:javascript
			function BallisticMissileGeometry(radius, height, heightRatio, radiusSegments) {
				
				THREE.Geometry.call(this);
				
				this.type = 'BallisticMissileGeometry';
				
				radiusSegments = (radiusSegments !== undefined) ? radiusSegments : 8;
				
				this.parameters = {
					radius: radius,
					height: height,
					heightRatio: heightRatio,
					radiusSegments: radiusSegments,
				};
				
				var headHeight = height / (heightRatio + 1) * heightRatio;
				var bodyHeight = height / (heightRatio + 1);
				
				var head = new THREE.CylinderGeometry(0, radius, headHeight, radiusSegments);
				this.merge(head, new THREE.Matrix4().compose(
					new THREE.Vector3(0, 0, height / 2 - headHeight / 2),
					new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI / 2, 0, 0, 'XYZ')),
					new THREE.Vector3(1, 1, 1)
				), 0);
				
				var body = new THREE.CylinderGeometry(radius, radius, bodyHeight, radiusSegments);
				this.merge(body, new THREE.Matrix4().compose(
					new THREE.Vector3(0, 0, -height / 2 + bodyHeight / 2),
					new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI / 2, 0, 0, 'XYZ')),
					new THREE.Vector3(1, 1, 1)
				), 1);
			}
			BallisticMissileGeometry.prototype = Object.create(THREE.Geometry.prototype);
			BallisticMissileGeometry.prototype.constructor = BallisticMissileGeometry;
		:javascript
			function Missile(geometry, material) {
			
				THREE.Mesh.call(this, geometry, material);
				
				this.mass = 1;
				
				this.velocity = new THREE.Vector3(0, 0, 0);
				this.target = new THREE.Vector3(0, 0, 0);
				
				this.maxForce = 50;
				this.maxSpeed = 50;
				
				this.maxSeeAhead = 50;
				this.maxAvoidForce = 120;
				
				this.obstacles = [];
			}
			Missile.prototype = Object.assign(Object.create(THREE.Mesh.prototype), {
				
				constructor: Missile,
				
				updateCenter: function () {
					if (!this.geometry.boundingSphere)
						this.geometry.computeBoundingSphere();
					this.center = this.localToWorld(this.geometry.boundingSphere.center.clone());
				},
				
				getSteerForce: function () {
					return this.target.clone().sub(this.center)
						.setLength(this.maxSpeed)
						.sub(this.velocity);
				},
				
				getAvoidForce: function () {
					
					var avoidForce = new THREE.Vector3(0, 0, 0);
					
					var ahead = this.maxSeeAhead * (this.velocity.length() / this.maxSpeed);
					
					var offsetProjLengthMin = Number.MAX_VALUE;
					for (var i = 0; i < this.obstacles.length; i++) {
						
						var obstacle = this.obstacles[i];
						
						var offset = obstacle.center.clone().sub(this.center);
						var offsetProj = offset.clone().projectOnVector(this.velocity);
						var offsetProjLength = offsetProj.length();
						var steerOffset = offsetProj.clone().sub(offset);
						
						var inFront = (offset.clone().dot(this.velocity) > 0);
						var needBlock = (steerOffset.length() < obstacle.radius + this.geometry.parameters.radius);
						var closeEnough = (offsetProjLength < ahead + obstacle.radius);
						
						if (inFront && needBlock && closeEnough && offsetProjLength < offsetProjLengthMin) {
							
							offsetProjLengthMin = offsetProjLength;
							avoidForce.copy(steerOffset.clone().setLength(this.maxAvoidForce));
						}
					}
					
					return avoidForce;
				},
				
				updateAxisFront: function () {
					this.updateMatrixWorld();
					this.axisFront = this.localToWorld(new THREE.Vector3(0, 0, 1)).sub(this.position);
				},
				
				updateRotation: function () {
					
					if (this.rotation.order !== 'YXZ')
						this.rotation.reorder('YXZ');
					
					var rotationZ = this.rotation.z;
					
					var xAxis = this.axisFront.clone().cross(this.velocity).normalize();
					if (xAxis.length() === 0)
						xAxis.set(1, 0, 0);
					
					var zAxis = this.velocity.clone().normalize();
					var yAxis = zAxis.clone().cross(xAxis).normalize();
					
					this.rotation.setFromRotationMatrix(new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis));
					this.rotation.z = rotationZ;
				},
				
				update: function (delta) {
					
					this.updateCenter();
					this.updateAxisFront();
					
					var force = new THREE.Vector3(0, 0, 0);
					
					var steerForce = this.getSteerForce();
					var avoidForce = this.getAvoidForce();
					
					force.add(steerForce).add(avoidForce).clampLength(0, this.maxForce);
					
					this.velocity.addScaledVector(force, delta / this.mass).clampLength(0, this.maxSpeed);
					this.position.addScaledVector(this.velocity, delta);
					
					this.updateRotation();
					
					this.onAfterUpdate();
				},
				
				onAfterUpdate: function () {},
				
			});
		:javascript
			function BallisticMissile(geometry, material) {
			
				Missile.call(this, geometry, material);
				
				this.enoughHeight = 400;
				this.enoughClosed = 400;
				
				this.state = 'up';
			}
			BallisticMissile.prototype = Object.assign(Object.create(Missile.prototype), {
				
				constructor: BallisticMissile,
				
				getDirection: function () {
					switch (this.state) {
						case 'up':
							return this.axisFront.clone();
						case 'front':
							return this.target.clone().sub(this.center).setY(0);
						default:
							return this.target.clone().sub(this.center);
					}
				},
				
				getSteerForce: function () {
					return this.getDirection()
						.setLength(this.maxSpeed)
						.sub(this.velocity);
				},
				
				onAfterUpdate: function () {
					if (this.state === 'up' && this.center.y >= this.enoughHeight)
						this.state = 'front';
					if (this.state === 'front' && this.center.clone().sub(this.target).setY(0).length() < this.enoughClosed)
						this.state = 'down';
				},
				
			});
		:javascript
			function TetragonalPrismGeometry(width, height, depthTop, depthBottom) {
			
				THREE.Geometry.call(this);
				
				this.type = 'TetragonalPrismGeometry';
				
				this.parameters = {
					width: width,
					height: height,
					depthTop: depthTop,
					depthBottom: depthBottom,
				};
				
				var halfWidth = width / 2;
				var halfDepthTop = depthTop / 2;
				
				this.vertices.push(
					new THREE.Vector3(0, height, -halfDepthTop),
					new THREE.Vector3(0, height, halfDepthTop),
					new THREE.Vector3(-halfWidth, 0, -halfDepthTop),
					new THREE.Vector3(halfWidth, 0, -halfDepthTop),
					new THREE.Vector3(-halfWidth, 0, depthBottom - halfDepthTop),
					new THREE.Vector3(halfWidth, 0, depthBottom - halfDepthTop));
				
				this.faces.push(
					new THREE.Face3(0, 3, 2),
					new THREE.Face3(0, 2, 1),
					new THREE.Face3(1, 2, 4),
					new THREE.Face3(0, 1, 3),
					new THREE.Face3(1, 5, 3),
					new THREE.Face3(2, 3, 4),
					new THREE.Face3(5, 4, 3),
					new THREE.Face3(1, 4, 5));
				
				// TODO
				this.faceVertexUvs[0].push(
					[new THREE.Vector2(1, 1), new THREE.Vector2(0, 0), new THREE.Vector2(1, 0)],
					[new THREE.Vector2(1, 1), new THREE.Vector2(0, 0), new THREE.Vector2(1, 0)],
					[new THREE.Vector2(1, 1), new THREE.Vector2(0, 0), new THREE.Vector2(1, 0)],
					[new THREE.Vector2(1, 1), new THREE.Vector2(0, 0), new THREE.Vector2(1, 0)],
					[new THREE.Vector2(1, 1), new THREE.Vector2(0, 0), new THREE.Vector2(1, 0)],
					[new THREE.Vector2(1, 1), new THREE.Vector2(0, 0), new THREE.Vector2(1, 0)],
					[new THREE.Vector2(1, 1), new THREE.Vector2(0, 0), new THREE.Vector2(1, 0)],
					[new THREE.Vector2(1, 1), new THREE.Vector2(0, 0), new THREE.Vector2(1, 0)]);
				
				this.computeFaceNormals();
			}
			TetragonalPrismGeometry.prototype = Object.create(THREE.Geometry.prototype);
			TetragonalPrismGeometry.prototype.constructor = TetragonalPrismGeometry;
		:javascript
			function AntiBallisticMissileGeometry(width, height, depth) {
				
				THREE.Geometry.call(this);
				
				this.type = 'AntiBallisticMissileGeometry';
				
				this.parameters = {
					width: width,
					height: height,
					depth: depth,
				};
				
				var unitWidth = width / 5;
				var unitHeight = height / 5;
				var unitDepth = depth / 4;
				
				var body = new THREE.BoxGeometry(unitWidth, unitHeight, depth);
				this.merge(body, new THREE.Matrix4().compose(
					new THREE.Vector3(0, 0, 0),
					new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0, 'XYZ')),
					new THREE.Vector3(1, 1, 1)
				), 0);
				
				var wing = new TetragonalPrismGeometry(unitHeight, unitWidth * 2, unitDepth, unitDepth);
				this.merge(wing, new THREE.Matrix4().compose(
					new THREE.Vector3(unitWidth * 0.5, 0, unitDepth * -0.25),
					new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, -Math.PI / 2, 'XYZ')),
					new THREE.Vector3(1, 1, 1)
				), 0);
				this.merge(wing, new THREE.Matrix4().compose(
					new THREE.Vector3(unitWidth * -0.5, 0, unitDepth * -0.25),
					new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, Math.PI / 2, 'XYZ')),
					new THREE.Vector3(1, 1, 1)
				), 0);
				
				var subWing = new TetragonalPrismGeometry(unitHeight, unitWidth, unitDepth / 2, unitDepth / 2);
				this.merge(subWing, new THREE.Matrix4().compose(
					new THREE.Vector3(unitWidth * 0.5, 0, unitDepth * -1.75),
					new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, -Math.PI / 2, 'XYZ')),
					new THREE.Vector3(1, 1, 1)
				), 0);
				this.merge(subWing, new THREE.Matrix4().compose(
					new THREE.Vector3(unitWidth * -0.5, 0, unitDepth * -1.75),
					new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, Math.PI / 2, 'XYZ')),
					new THREE.Vector3(1, 1, 1)
				), 0);
				
				var tail = new TetragonalPrismGeometry(unitWidth, unitHeight * 3, unitDepth / 2, unitDepth);
				this.merge(tail, new THREE.Matrix4().compose(
					new THREE.Vector3(0, unitHeight * 0.5, unitDepth * -1.75),
					new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0, 'XYZ')),
					new THREE.Vector3(1, 1, 1)
				), 0);
			}
			AntiBallisticMissileGeometry.prototype = Object.create(THREE.Geometry.prototype);
			AntiBallisticMissileGeometry.prototype.constructor = AntiBallisticMissileGeometry;
		:javascript
			var scene, camera, renderer, controls;
			var clock = new THREE.Clock();
			var ballisticMissile, antiBallisticMissile;
			var explosion, explosionables = [];
			
			init();
			animate();

			function init() {
				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
				camera.position.set(0, 500, 500);

				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x888888);
				document.body.appendChild(renderer.domElement);
				
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				window.addEventListener('resize', onWindowResize, false);
				
				var gridXZ = new THREE.GridHelper(400, 40, 0xff0000, 0xffffff);
				scene.add(gridXZ);
				
				// ballisticMissile
				ballisticMissile = new BallisticMissile(
					new BallisticMissileGeometry(10, 40, 2 / 3, 32),
					new THREE.MeshNormalMaterial());
				ballisticMissile.position.set(-300, 0, -300);
				ballisticMissile.rotation.set(-Math.PI / 2, 0, 0);
				ballisticMissile.target.set(300, 200, 300);
				scene.add(ballisticMissile);
				
				// building
				var building = createBuilding(50, ballisticMissile.target.y, 50);
				building.position.copy(ballisticMissile.target.clone().setY(building.position.y));
				scene.add(building);
				
				explosionables.push(building);
				
				// balloons
				var obstacles = [];
				for (var i = 0; i < 10; i++) {
					
					var offset = new THREE.Vector3(
						Math.random() * 200 - 100,
						Math.random() * 100,
						Math.random() * 200 - 100);
					
					var balloon = createBalloon(20, 40, 20);
					balloon.position.copy(ballisticMissile.target).add(offset);
					scene.add(balloon);
					
					explosionables.push(balloon);
					
					if (!balloon.geometry.boundingSphere)
						balloon.geometry.computeBoundingSphere();
					
					obstacles.push(balloon.geometry.boundingSphere.clone().translate(balloon.position));
				}
				ballisticMissile.obstacles = obstacles;
				
				// explosion
				explosion = createExplosion(60);
				scene.add(explosion);
				
				// antiBallisticMissile
				antiBallisticMissile = new THREE.Mesh(
					new AntiBallisticMissileGeometry(50, 30, 35),
					new THREE.MeshNormalMaterial());
				antiBallisticMissile.position.set(-300, 0, 300);
				antiBallisticMissile.rotation.set(-Math.PI / 6, Math.PI * (3 / 4), 0, 'YXZ')
				scene.add(antiBallisticMissile);
			}
			
			function createBuilding(width, height, depth) {
			
				var building = new THREE.Mesh(
					new THREE.BoxGeometry(width, height, depth),
					new THREE.MeshNormalMaterial())
				building.position.y = height / 2;
				
				building.explode = function () {
					this.exploded = true;
					this.material.transparent = true;
				};
				
				building.explodedUpdate = function (delta) {
					if (this.exploded && this.material.opacity > 0) {
						this.position.y -= delta * (height / 10);
						this.material.opacity = Math.max(0, this.material.opacity - delta / 2);
					}
				};
				
				return building;
			}
			
			function createBalloon(width, height, depth) {
				
				var balloon = new THREE.Mesh(
					new THREE.BoxGeometry(width, height, depth),
					new THREE.MeshNormalMaterial());
					
				balloon.explode = function () {
					this.exploded = true;
					this.material.transparent = true;
				};
				
				balloon.explodedUpdate = function (delta) {
					if (this.exploded && this.material.opacity > 0) {
						this.position.y -= delta * (height / 2);
						this.material.opacity = Math.max(0, this.material.opacity - delta / 3);
					}
				};
				
				return balloon;
			}
			
			function createExplosion(radius) {
				
				var explosion = new THREE.Mesh(
					new THREE.IcosahedronGeometry(radius, 4), 
					new THREE.ShaderMaterial({
						uniforms: { 
							tExplosion: {
								value: new THREE.TextureLoader().load('../src/images/explosion.png'),
							},
							time: {
								value: 0.0 
							},
						},
						vertexShader: document.getElementById('explosion_vertex_shader').textContent,
						fragmentShader: document.getElementById('explosion_fragment_shader').textContent,
					}));
				
				var scale = 0;
				var direction = 1;
				
				var speed = function () {
					return direction > 0 ? 1 : 0.2;
				};
				
				explosion.show = function () {
					scale = 0.01;
					this.scale.set(scale, scale, scale);
				};
				
				explosion.update = function (delta) {
					
					this.visible = (scale !== 0);
					
					if (scale === 0)
						return;
					
					this.material.uniforms.time.value += 0.25 * delta;
					
					scale += direction * delta * speed();
					scale = THREE.Math.clamp(scale, 0, 1);
					
					if ((direction > 0 && scale === 1) || (direction < 0 && scale === 0))
						direction *= -1;
					
					if (scale > 0)
						this.scale.set(scale, scale, scale);
				};
				
				return explosion;
			}
			
			function checkCollision() {
				
				var obb = new OBB(ballisticMissile);
				
				for (var i = 0; i < explosionables.length; i++) {
				
					var explosionable = explosionables[i];
					
					if (!explosionable.exploded) {
						
						var explosionablesOBB = new OBB(explosionable);
						if (obb.intersectsOBB(explosionablesOBB)) {
							
							ballisticMissile.exploded = true;
							ballisticMissile.visible = false;
							
							explosion.position.copy(ballisticMissile.position);
							explosion.show();
							
							explosionable.explode();
							
							return;
						}
					}
				}
			}
			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				
				var delta = clock.getDelta();
				
				ballisticMissile.update(delta);
				
				if (!ballisticMissile.exploded)
					checkCollision();
				
				for (var i = 0; i < explosionables.length; i++)
					explosionables[i].explodedUpdate(delta);
				explosion.update(delta);
				
				controls.update();
				requestAnimationFrame(animate);
				renderer.render(scene, camera);
			}